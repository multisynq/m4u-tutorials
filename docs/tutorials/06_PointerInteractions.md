## Tutorial 6 - Pointer Interactions
*How to use the Interactable mixin to receive pointer-hit events.*

*Uses the colorableCube, interactableCube and groundPlane prefabs.*

![](images/image15.gif)

*Tutorial 6 demonstrates direct user interactions to both dynamically create and destroy objects within the scene.*

We add a BaseActor class that is shown as a ground plane. Its pawn includes the **Interactable** mixin.

The **Croquet Interactable System** that appears on the **Croquet** object in this scene provides click detection for all objects that have the **Croquet Interactable Component**. On a pointer-down interaction, the system performs a raycast and publishes a "pointerHit" event listing all interactable game objects along that ray, sorted by increasing distance. The bridge to JavaScript figures out the corresponding actors, and publishes an event that goes via the reflector to every client's model.

In this tutorial, the BaseActor is the only one that subscribes to "pointerHit" events. It looks at the first actor in the supplied list. If that actor is itself, it spawns a new child at the clicked point, assigning it a "layers" property value - an array of strings - that will be provided if that actor appears in a future pointerHit event.

If the first hit is not the BaseActor, but another actor whose "layers" property shows that it was spawned by the BaseActor, we publish a "kill" event that the spawned actor will respond to by destroying itself.

```js
class BaseActor extends mix(Actor).with(AM_Spatial) {
    get gamePawnType() {
        return "groundPlane";
    }

    init(options) {
        super.init(options);
        this.subscribe("input", "pointerHit", this.doPointerHit);
    }

    doPointerHit(e) {
        const { actor, xyz, layers } = e.hits[0];
        if (actor === this) {
            this.doSpawn(xyz);
        } else if (layers.includes('spawnedByBase')) {
            this.publish(actor.id, 'kill');
        }
    }

    doSpawn(xyz) {
        TestActor.create({ parent: this, layers: ['spawnedByBase'], translation: xyz });
    }
}

BaseActor.register('BaseActor');
```

TestActor now uses "interactableCube" as its pawn type, which also includes the **Interactable** mixin. However, as mentioned above, this TestActor does not handle any "pointerHit" events itself. It subscribes only to the "kill" event with the actor's own id as scope, if and when published by the BaseActor.

```js
class BaseActor extends mix(Actor).with(AM_Spatial) {
    get gamePawnType() {
        return "groundPlane";
    }

    init(options) {
        super.init(options);
        this.subscribe("input", "pointerHit", this.doPointerHit);
    }

    doPointerHit(e) {
        const { actor, xyz, layers } = e.hits[0];
        if (actor === this) {
            this.doSpawn(xyz);
        } else if (layers.includes('spawnedByBase')) {
            this.publish(actor.id, 'kill');
        }
    }

    doSpawn(xyz) {
        TestActor.create({ parent: this, layers: ['spawnedByBase'], translation: xyz });
    }
}

BaseActor.register('BaseActor');
```

This example demonstrates two types of event distribution, with important differences. An event from the Unity side (whether generated by a system, as in the case of "pointerHit", or by a pawn using **Say** or **Publish** ) must travel via the reflector so that every client receives the event. On the other hand, an event that is published by an actor (such as the "kill" event here) is processed immediately and synchronously by any other actor that subscribes to it, with no reflector journey involved. Such actor-to-actor events are a highly efficient way to achieve loose coupling between the entities involved.

The end result is that raycasting only needs to happen in the view of the client who actually clicked the pointer, but all clients respond identically to that click.